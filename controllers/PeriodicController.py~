import threading
import time


class Controller(threading.Thread):
  def __init__(self):
    super(Controller, self).__init__()
    self._planets = set([])

  def addplanet(self, planet):
    self._planets.add(planet)

class WeatherControllerDecorator(Controller):
  def __init__(self, controller):
    super(WeatherControllerDecorator, self).__init__()
    self._base_controller = controller

  def run(self):
    self._base_controller.start()


class PeriodicController(Controller):
  def __init__(self):
    super(PeriodicController, self).__init__()
    self._planet_season_clock = {}

  def run(self):
    for planet in self._planets:
      self._planet_season_clock[planet] = 0
    while True:
      for planet, season_clock in self._planet_season_clock.items():
        # Half revolution around the parent star triggers season change.
        planet_period = data_reader.GetPeriod(planet) / 2
        new_clock = (season_clock + 1) % planet_period
        self._planet_season_clock[planet] = new_clock
        if new_clock == 0:  # We have circled half around the parent star.
          with planet.season_change_lock:
            # Switch seasons.
            temp_zone = planet.summer_zones
            planet.summer_zones = planet.winter_zones
            planet.winter_zones = temp_zone
        time.sleep(1) # * 60)  # 1 minute.


class RainController(WeatherControllerDecorator):
  def __init__(self, weathercontroller):
    super(RainController, self).__init__(weathercontroller)
    self._planet_rain_locations = None
    
  def run(self):
    while True:
      for planet in self.planets:
        self._planet_rain_locations = collections.defaultdict(list)
        min_latitude, max_latitude = GetAllowedRainLatitudes(planet)
        count_rain_regions = random.randint(20, 100)
        for _ in range(count_rain_regions):
          start_latitude = random.uniform(min_latitude, max_latitude)
          start_longitude = random.uniform(*_LONGITUDE_RANGE)
          end_latitude = random.uniform(min_latitude, max_latitude)
          end_longitude = random.uniform(*_LONGITUDE_RANGE)
          start_location = Location(start_latitude, start_longitude)
          end_location = Locaton(end_latitude, end_longitude)
          self._planet_rain_locations[planet].append(arrange(start_location, end_location))
          # Location.sort is a class method that adjusts two locations in a botton-left, top-right fashion.
      time.sleep(5)  # It rains for 30 seconds * len(self.planets) on a planet.


def CreateWeatherController(base_weather, weather_decorators):
  def CreateBaseController(base_weather):
    if base_weather == 'periodic':
      return PeriodicController()

  def CreateWeatherDecorator(decorator, base_controller):
    if decorator == 'rain':
      return RainController(base_controller)

  weather_controller = CreateBaseController(base_weather)
  # for decorator_name in weather_decorators:
  #   weather_controller = CreateWeatherDecorator(decorator_name, weather_controller)
  return weather_controller

def arrange(location_a, location_b):
  if location_a.latitude < location_b.latitude:
    if location_b.longitude < location_a.longitude:
      ret_tuple = (Location(latitude=location_a.latitude, longitude=location_b.longitude),
                   Location(latitude=location_b.latitude, longitude=location_a.longitude))
      return ret_tuple
    else:
      return (location_a, location_b)
  elif location_a.latitude == location_b.latitude:
    if location_b.longitude < location_a.longitude:
      ret_tuple = (Location(latitude=location_a.latitude, longitude=location_b.longitude),
                   Location(latitude=location_b.latitude, longitude=location_a.longitude))
      return ret_tuple
    else:
      return (location_a, location_b)
  else:  # i.e. location_a.latitude > location_b.latitude:
    if location_a.longitude < location_b.longitude:
      ret_tuple = (Location(latitude=location_b.latitude, longitude=location_a.longitude),
                   Location(latitude=location_a.latitude, longitude=location_b.longitude))
      return ret_tuple
    else:
      return (location_b, location_a)
    
def GetAllowedRainLatitudes(planet):
  planet_data = data_reader.GetPlanetData(planet)
  rain_zones = data_reader.GetRainZones(planet)
  all_zones = planet_data['zones'].items()
  zone_data = {k: all_zones[k] for k in all_zones if k in rain_zones}
  regions = [latitude for zone in zone_data.values() for latitude in zone]
  return min(regions), max(regions)

